const ranGen = require('./secjs-random-generate')
const fs = require('fs')

class SECGroup {
  /**
   * @param  {Object} config - JSON format configurations for initialization
   */
  constructor (config) {
    this.accAddrLength = config.accAddrLength // 128
    this.groupIdRange = {
      'min': 1,
      'max': 10
    }

    // Current node generated group id for its peers
    this.generatedPeerGroupId = {
      // 'account address': group ID
    }

    // Distributed table that records each node's group id
    this.accGroupIdDht = {
      // 'account address': group ID
    }

    // Used to collect and add up each group ID generated times from other peer nodes
    this.accGroupIdStatisticsDht = {
      // 'account address': {
      //    'group ID': add up value
      // }, ...
    }
  }

  /**
   * Generate a group id
   * @return {Number}
   */
  generateGroupId () {
    let length = this.groupIdRange['max'] - this.groupIdRange['min']
    let result = ranGen.randomGenerate('number', length)

    return (result + this.groupIdRange['min'])
  }

  /**
   * This function generates group ids for all the peer nodes
   * @param {Array} peerAddrList - Peer nodes' address list
   * @return {None}
   */
  generateGroupIds (peerAddrList) {
    let self = this
    if (!Array.isArray(peerAddrList)) {
      throw new TypeError('Invalid peer node address input type')
    } else {
      if (!this._duplicateAddrCheck(peerAddrList)) {
        throw new Error('Input contains duplicate addresses')
      }
    }

    peerAddrList.forEach(function (peerAddr) {
      if (!self._accAddrValidate(peerAddr)) {
        throw new Error('Invalid peer node address')
      }

      self.generatedPeerGroupId[peerAddr] = self.generateGroupId()
    })
  }

  /**
   * This function returns the group ID for a specific address
   * @param  {String} accAddr - Account address
   * @return {Number}
   */
  getGroupId (accAddr) {
    if (!this._accAddrValidate(accAddr)) {
      throw new Error('Invalid account address')
    }

    if (this.accGroupIdDht[accAddr] === undefined) {
      return null
    }

    return this.accGroupIdDht[accAddr]
  }

  /**
   * This function sets the group ID for a specific address
   * @param  {String} accAddr - Account address
   * @param  {Number} groupId - Group ID value which will be set to the corresponding account address
   * @return {None}
   */
  setGroupId (accAddr, groupId) {
    if (!this._accAddrValidate(accAddr)) {
      throw new Error('Invalid account address')
    }

    if (!this._groupIdValidate(groupId)) {
      throw new RangeError('Invalid group Id, out of range')
    }

    this.accGroupIdDht[accAddr] = groupId
  }

  /**
   * This function updates the table which stores the frequency of each group ID generated by its peer nodes
   * @param  {Object} peerAccGroupIdDht - Other peer nodes generated group ID table
   * @return {None}
   */
  updateStatisticsDht (peerAccGroupIdDht) {
    Object.keys(peerAccGroupIdDht).forEach(function (accAddr) {
      let groupId = peerAccGroupIdDht[accAddr]
      if (!this._accAddrValidate(accAddr)) {
        throw new Error('Invalid Group ID DHT From Peer Nodes (Account Address Invalid)')
      }

      if (!this._groupIdValidate(groupId)) {
        throw new RangeError('Invalid Group ID DHT From Peer Nodes (Group ID out of range)')
      }

      if (this.accGroupIdStatisticsDht[accAddr] === undefined) {
        this.accGroupIdStatisticsDht[accAddr] = {}
      }

      if (this.accGroupIdStatisticsDht[accAddr][groupId] === undefined) {
        this.accGroupIdStatisticsDht[accAddr][groupId] = 1
      } else {
        this.accGroupIdStatisticsDht[accAddr][groupId] += 1
      }
    })
  }

  /**
   * This function finally determined the located group IDs for each nodes (unchangable during this working period).
   * @return {None}
   */
  setGroupIdDht () {
    Object.keys(this.accGroupIdStatisticsDht).forEach(function (accAddr) {
      let result = Object.keys(this.accGroupIdStatisticsDht[accAddr]).forEach(function (groupId) {
        let maxGroupId = 0
        if (this.accGroupIdStatisticsDht[accAddr][groupId] > maxGroupId) {
          maxGroupId = this.accGroupIdStatisticsDht[accAddr][groupId]
        }
      })

      if (result !== 0) {
        this.accGroupIdDht[accAddr] = result
      }
    })
  }

  /**
   * This function appends the group ID statistics table into a JSON file
   * @param  {String} file - The json file path and name
   * @param  {Object} content - Data to be written, default data is this.accGroupIdDht
   * @return {None}
   */
  storeGroupIdTableToFile (file, content = this.accGroupIdDht) {
    let timeStamp = new Date().getTime()
    let newLine = '\r\n'
    let writeData = timeStamp.toString + newLine + JSON.stringify(content) + newLine
    fs.appendFile(file, writeData, function (err) {
      if (err) {
        throw err
      }
    })
  }

  /**
   * Validate the account address is legal
   * @param  {String} accAddr - Account address
   * @return {Boolean}
   */
  _accAddrValidate (accAddr) {
    if (typeof accAddr !== 'string') {
      return false
    }

    if (accAddr.length !== this.accAddrLength) {
      return false
    }

    return true
  }

  /**
   * Validate the group ID value is legal
   * @param  {Number} groupId - Group ID value
   * @return {Boolean}
   */
  _groupIdValidate (groupId) {
    if (typeof groupId !== 'number') {
      return false
    }

    if ((groupId > this.groupIdRange['max']) || (groupId < this.groupIdRange['min'])) {
      return false
    }

    return true
  }

  /**
   * Check whether the input array or json data contains duplicate addresses
   * @param  {Array, Object} addrList - input data which will be checked
   * @return {Boolean}
   */
  _duplicateAddrCheck (addrList) {
    if (Array.isArray(addrList)) {
      let sortedArray = addrList.sort()
      for (let i = 0; i < addrList.length; i++) {
        if (sortedArray[i] === sortedArray[i + 1]) {
          return false
        }
      }
    } else {
      try {
        JSON.parse(addrList)
      } catch (e) {
        throw new TypeError('Invalid input type, should be array type or json format')
      }
      let sortedArray = Object.keys(addrList).sort()
      for (let i = 0; i < sortedArray.length; i++) {
        if (sortedArray[i] === sortedArray[i + 1]) {
          return false
        }
      }
    }

    return true
  }
}

module.exports = SECGroup
